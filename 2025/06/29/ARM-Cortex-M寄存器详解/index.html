<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="ARM 处理器运行模式ARM 处理器有多种工作模式，不同模式下寄存器的使用和访问方式有所不同。以下是主要的运行模式： 用户模式（User Mode） 说明：是默认的运行模式，执行普通程序。该模式下不允许访问特权寄存器，只能访问通用寄存器 R0-R15。 特性：不能直接访问系统寄存器（如 CPSR）。  快速中断模式（FIQ Mode） 说明：当发生快速中断（FIQ）时，处理器会切换到此模式。FIQ">
<meta property="og:type" content="article">
<meta property="og:title" content="ARM Cortex-M寄存器详解">
<meta property="og:url" content="https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/">
<meta property="og:site_name" content="YAOHAN-LI">
<meta property="og:description" content="ARM 处理器运行模式ARM 处理器有多种工作模式，不同模式下寄存器的使用和访问方式有所不同。以下是主要的运行模式： 用户模式（User Mode） 说明：是默认的运行模式，执行普通程序。该模式下不允许访问特权寄存器，只能访问通用寄存器 R0-R15。 特性：不能直接访问系统寄存器（如 CPSR）。  快速中断模式（FIQ Mode） 说明：当发生快速中断（FIQ）时，处理器会切换到此模式。FIQ">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-29T09:27:53.000Z">
<meta property="article:modified_time" content="2025-06-29T10:32:46.880Z">
<meta property="article:author" content="YAOHAN-LI">
<meta property="article:tag" content="log">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>ARM Cortex-M寄存器详解</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- rss -->
    
    
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/sergodeeva">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2025/06/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&text=ARM Cortex-M寄存器详解"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&title=ARM Cortex-M寄存器详解"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&is_video=false&description=ARM Cortex-M寄存器详解"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=ARM Cortex-M寄存器详解&body=Check out this article: https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&title=ARM Cortex-M寄存器详解"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&title=ARM Cortex-M寄存器详解"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&title=ARM Cortex-M寄存器详解"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&title=ARM Cortex-M寄存器详解"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&name=ARM Cortex-M寄存器详解&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ARM-%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">ARM 处理器运行模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%EF%BC%88User-Mode%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">用户模式（User Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E4%B8%AD%E6%96%AD%E6%A8%A1%E5%BC%8F%EF%BC%88FIQ-Mode%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">快速中断模式（FIQ Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%BC%8F%EF%BC%88IRQ-Mode%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">中断请求模式（IRQ Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Supervisor-Mode%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">管理模式（Supervisor Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%BC%8F%EF%BC%88Abort-Mode%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">存储访问异常模式（Abort Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Undefined-Mode%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">未定义指令模式（Undefined Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F%EF%BC%88System-Mode%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">系统模式（System Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%88Monitor-Mode%EF%BC%89%EF%BC%88%E4%BB%85%E5%9C%A8-ARMv7-%E6%88%96%E6%9B%B4%E9%AB%98%E7%89%88%E6%9C%AC%E4%B8%AD%E5%AD%98%E5%9C%A8%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">监控模式（Monitor Mode）（仅在 ARMv7 或更高版本中存在）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARM-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">ARM 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88General-Purpose-Registers%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">通用寄存器（General Purpose Registers）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88PSR%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">程序状态寄存器（PSR）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Banked-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E9%93%B6%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">Banked 寄存器（银行寄存器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Control-Registers%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">控制寄存器（Control Registers）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%94%A8%E9%80%94%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">寄存器用途分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#R0-R3-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">R0~R3 寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R4-R11-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">R4~R11 寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R12IP%EF%BC%88Intra-Procedure-call-scratch-register%EF%BC%89%EF%BC%8C%E4%B8%B4%E6%97%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">R12	IP（Intra-Procedure-call scratch register），临时寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R13SP%EF%BC%88Stack-Pointer%EF%BC%89%EF%BC%8C%E6%A0%88%E6%8C%87%E9%92%88"><span class="toc-number">3.4.</span> <span class="toc-text">R13	SP（Stack Pointer），栈指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R14LR%EF%BC%88Link-Register%EF%BC%89%EF%BC%8C%E9%93%BE%E6%8E%A5%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E4%BF%9D%E5%AD%98%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.5.</span> <span class="toc-text">R14	LR（Link Register），链接寄存器，保存返回地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R15PC%EF%BC%88Program-Counter%EF%BC%89%EF%BC%8C%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">R15	PC（Program Counter），程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88PSR%EF%BC%89-1"><span class="toc-number">3.7.</span> <span class="toc-text">程序状态寄存器（PSR）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Banked-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E9%93%B6%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89-1"><span class="toc-number">3.8.</span> <span class="toc-text">Banked 寄存器（银行寄存器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Control-Registers%EF%BC%89-1"><span class="toc-number">3.9.</span> <span class="toc-text">控制寄存器（Control Registers）</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        ARM Cortex-M寄存器详解
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">YAOHAN-LI</span>
      </span>
      
    <div class="postdate">
        <time datetime="2025-06-29T09:27:53.000Z" itemprop="datePublished">2025-06-29</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="ARM-处理器运行模式"><a href="#ARM-处理器运行模式" class="headerlink" title="ARM 处理器运行模式"></a>ARM 处理器运行模式</h1><p>ARM 处理器有多种工作模式，不同模式下寄存器的使用和访问方式有所不同。以下是主要的运行模式：</p>
<h2 id="用户模式（User-Mode）"><a href="#用户模式（User-Mode）" class="headerlink" title="用户模式（User Mode）"></a>用户模式（User Mode）</h2><ul>
<li><strong>说明</strong>：是默认的运行模式，执行普通程序。该模式下不允许访问特权寄存器，只能访问通用寄存器 R0-R15。</li>
<li><strong>特性</strong>：不能直接访问系统寄存器（如 CPSR）。</li>
</ul>
<h2 id="快速中断模式（FIQ-Mode）"><a href="#快速中断模式（FIQ-Mode）" class="headerlink" title="快速中断模式（FIQ Mode）"></a>快速中断模式（FIQ Mode）</h2><ul>
<li><strong>说明</strong>：当发生快速中断（FIQ）时，处理器会切换到此模式。FIQ 模式下有更多的寄存器（R8–R14_fiq），以减少中断服务例程的上下文切换成本。</li>
<li><strong>特性</strong>：可以直接使用更多的寄存器（R8-R14_fiq），从而提高中断响应效率。</li>
</ul>
<h2 id="中断请求模式（IRQ-Mode）"><a href="#中断请求模式（IRQ-Mode）" class="headerlink" title="中断请求模式（IRQ Mode）"></a>中断请求模式（IRQ Mode）</h2><ul>
<li><strong>说明</strong>：发生中断时，处理器进入 IRQ 模式。IRQ 模式下有 R13_irq 和 R14_irq 等寄存器。</li>
<li><strong>特性</strong>：用于处理中断请求，处理程序必须保存&#x2F;恢复中断前的状态。</li>
</ul>
<h2 id="管理模式（Supervisor-Mode）"><a href="#管理模式（Supervisor-Mode）" class="headerlink" title="管理模式（Supervisor Mode）"></a>管理模式（Supervisor Mode）</h2><ul>
<li><strong>说明</strong>：通常由操作系统在系统调用时进入。此模式下，可以访问大部分系统寄存器。</li>
<li><strong>特性</strong>：可以执行特权操作，如操作系统调度、内存管理等。</li>
</ul>
<h2 id="存储访问异常模式（Abort-Mode）"><a href="#存储访问异常模式（Abort-Mode）" class="headerlink" title="存储访问异常模式（Abort Mode）"></a>存储访问异常模式（Abort Mode）</h2><ul>
<li><strong>说明</strong>：当发生存储访问错误时，处理器进入该模式。</li>
<li><strong>特性</strong>：处理器此时可以处理内存访问错误（如访问非法内存地址）。</li>
</ul>
<h2 id="未定义指令模式（Undefined-Mode）"><a href="#未定义指令模式（Undefined-Mode）" class="headerlink" title="未定义指令模式（Undefined Mode）"></a>未定义指令模式（Undefined Mode）</h2><ul>
<li><strong>说明</strong>：当执行无效或未定义的指令时，处理器进入此模式。</li>
<li><strong>特性</strong>：用于处理无效指令的异常。</li>
</ul>
<h2 id="系统模式（System-Mode）"><a href="#系统模式（System-Mode）" class="headerlink" title="系统模式（System Mode）"></a>系统模式（System Mode）</h2><ul>
<li><strong>说明</strong>：系统模式下，所有的寄存器和权限都与用户模式相同，但此时具有更高的权限。</li>
<li><strong>特性</strong>：可以进行特权操作，且不受到用户模式的限制。</li>
</ul>
<h2 id="监控模式（Monitor-Mode）（仅在-ARMv7-或更高版本中存在）"><a href="#监控模式（Monitor-Mode）（仅在-ARMv7-或更高版本中存在）" class="headerlink" title="监控模式（Monitor Mode）（仅在 ARMv7 或更高版本中存在）"></a>监控模式（Monitor Mode）（仅在 ARMv7 或更高版本中存在）</h2><ul>
<li><strong>说明</strong>：主要用于虚拟化或调试支持，允许访问一些调试寄存器。</li>
<li><strong>特性</strong>：通过虚拟化支持或调试工具，提供对操作系统的调试控制。</li>
</ul>
<h1 id="ARM-寄存器"><a href="#ARM-寄存器" class="headerlink" title="ARM 寄存器"></a>ARM 寄存器</h1><h2 id="通用寄存器（General-Purpose-Registers）"><a href="#通用寄存器（General-Purpose-Registers）" class="headerlink" title="通用寄存器（General Purpose Registers）"></a>通用寄存器（General Purpose Registers）</h2><pre><code>    ARM 的寄存器命名为 R0 到 R15，总共 16 个：

    寄存器	说明
    R0–R3	参数寄存器，传递函数参数或临时数据
    R4–R11	被调用者保存寄存器，用于保存局部变量
    R12	IP（Intra-Procedure-call scratch register），临时寄存器
    R13	SP（Stack Pointer），栈指针
    R14	LR（Link Register），链接寄存器，保存返回地址
    R15	PC（Program Counter），程序计数器
</code></pre>
<h2 id="程序状态寄存器（PSR）"><a href="#程序状态寄存器（PSR）" class="headerlink" title="程序状态寄存器（PSR）"></a>程序状态寄存器（PSR）</h2><pre><code>    ARM 中的 PSR 由 CPSR（Current Program Status Register）和 SPSR（Saved Program Status Register）组成。PSR 用来存储程序的状态、条件码和模式信息。

    CPSR（当前程序状态寄存器）
    位	说明
    31	N：负标志位（Negative）
    30	Z：零标志位（Zero）
    29	C：进位标志位（Carry）
    28	V：溢出标志位（Overflow）
    27–24	处理器模式（Mode）
    7–0	条件标志，包含四个标志位：N、Z、C、V

    SPSR（保存程序状态寄存器）
    SPSR 在异常发生时保存 CPSR 的值，以便在异常返回时恢复状态。
</code></pre>
<h2 id="Banked-寄存器（银行寄存器）"><a href="#Banked-寄存器（银行寄存器）" class="headerlink" title="Banked 寄存器（银行寄存器）"></a>Banked 寄存器（银行寄存器）</h2><pre><code>    在 ARM 中，某些模式下有 banked 寄存器，这些寄存器在不同的处理器模式下是分开的，用于保存处理器模式切换时的状态。

    模式	寄存器
    User	无 banked 寄存器
    FIQ	R8_fiq–R14_fiq、SPSR_fiq
    IRQ	R13_irq、R14_irq、SPSR_irq
    Supervisor	R13_svc、R14_svc、SPSR_svc
    Abort	R13_abt、R14_abt、SPSR_abt
    Undefined	R13_und、R14_und、SPSR_und
    System	R13_sys、R14_sys、SPSR_sys
</code></pre>
<h2 id="控制寄存器（Control-Registers）"><a href="#控制寄存器（Control-Registers）" class="headerlink" title="控制寄存器（Control Registers）"></a>控制寄存器（Control Registers）</h2><pre><code>    在 ARM 中，有一些专用的控制寄存器来配置处理器的一些特性，例如缓存控制、异常控制等。这些寄存器包括：

    寄存器	说明
    SCTLR	系统控制寄存器，配置缓存、对齐等
    ACTLR	高级控制寄存器，控制系统的高级功能
    CPACR	协处理器访问控制寄存器
</code></pre>
<h1 id="寄存器用途分析"><a href="#寄存器用途分析" class="headerlink" title="寄存器用途分析"></a>寄存器用途分析</h1><h2 id="R0-R3-寄存器"><a href="#R0-R3-寄存器" class="headerlink" title="R0~R3 寄存器"></a>R0~R3 寄存器</h2><ul>
<li><p><strong>函数参数传递（Function Argument Passing）</strong><br>  R0 到 R3 寄存器通常用于 传递函数参数。在 ARM 调用约定中，前 4 个参数（即第一个至第四个参数）通过这 4 个寄存器传递。对于更多的参数，通常通过栈传递。<br><br>  例如，假设有一个函数 foo(int a, int b, int c, int d)，那么在调用时：<br><br>  a 会存储在 R0 中<br><br>  b 会存储在 R1 中<br><br>  c 会存储在 R2 中<br><br>  d 会存储在 R3 中</p>
</li>
<li><p><strong>函数返回值（Return Value）</strong><br>  R0 还用来返回函数的结果。如果函数的返回值是 32 位数据（如整数或指针），它会通过 R0 返回给调用者。<br><br>  如果返回值较大（比如结构体、数组），则会使用其他机制（如通过栈或其他寄存器）。</p>
</li>
<li><p><strong>临时数据存储（Temporary Storage）</strong><br>  R0-R3 也可以用来存储临时数据或进行计算。例如，在进行一些算法处理时，它们可以作为临时变量的存储空间。</p>
</li>
<li><p><strong>寄存器保存规范（Calling Convention）</strong><br>  在 ARM 的 AAPCS（ARM Architecture Procedure Call Standard） 调用约定中，R0-R3 的用途如下：<br><br>  寄存器    用途<br>  R0    第一个函数参数 &#x2F; 返回值<br>  R1    第二个函数参数<br>  R2    第三个函数参数<br>  R3    第四个函数参数</p>
</li>
<li><p><strong>R0-R3 寄存器使用示例</strong><br>  假设我们有以下 ARM 汇编代码：<br><br>  .global _start<br>  _start:<br>  MOV R0, #5       &#x2F;&#x2F; 将常数 5 存储到 R0 寄存器<br>  MOV R1, #10      &#x2F;&#x2F; 将常数 10 存储到 R1 寄存器<br>  ADD R2, R0, R1   &#x2F;&#x2F; R2 &#x3D; R0 + R1，即 R2 &#x3D; 5 + 10 &#x3D; 15<br>  MOV R3, R2       &#x2F;&#x2F; 将 R2 的值复制到 R3<br>  &#x2F;&#x2F; 此时 R3 存储着 15<br>  解释：<br>  R0 被用来存储数字 5。<br>  R1 存储数字 10。<br>  执行 ADD 指令后，R2 存储了 R0 + R1 的结果，即 15。<br>  最后，将 R2 的值存储到 R3 中，R3 存储了 15。</p>
</li>
</ul>
<h2 id="R4-R11-寄存器"><a href="#R4-R11-寄存器" class="headerlink" title="R4~R11 寄存器"></a>R4~R11 寄存器</h2><pre><code>    | 寄存器     | 说明                      | 用途               |
    | ------- | ----------------------- | ---------------- |
    | **R4**  | 被调用者保存寄存器（callee-saved） | 用于函数中保存局部变量或临时数据 |
    | **R5**  | 被调用者保存寄存器（callee-saved） | 用于函数中保存局部变量或临时数据 |
    | **R6**  | 被调用者保存寄存器（callee-saved） | 用于函数中保存局部变量或临时数据 |
    | **R7**  | 被调用者保存寄存器（callee-saved） | 用于函数中保存局部变量或临时数据 |
    | **R8**  | 被调用者保存寄存器（callee-saved） | 用于函数中保存局部变量或临时数据 |
    | **R9**  | 被调用者保存寄存器（callee-saved） | 用于函数中保存局部变量或临时数据 |
    | **R10** | 被调用者保存寄存器（callee-saved） | 用于函数中保存局部变量或临时数据 |
    | **R11** | 被调用者保存寄存器（callee-saved） | 用于函数中保存局部变量或临时数据 |
</code></pre>
<ul>
<li><p><strong>调用约定</strong><br>  根据 AAPCS（ARM Architecture Procedure Call Standard） 调用约定：<br><br>  R4~R11 是 被调用者保存寄存器，这意味着函数在使用这些寄存器之前，应该保存它们的原值（通常是通过栈操作保存）。如果一个函数要改变这些寄存器的值，它必须在返回之前恢复它们的值，以保持调用者的状态不变。<br><br>  在调用函数时，调用者不需要担心这些寄存器的值会被修改，函数保证返回时它们保持不变。</p>
</li>
<li><p><strong>示例</strong><br>  假设你有一个函数 foo，并且它使用了 R4 和 R5 寄存器来存储临时数据。按照调用约定，它需要在使用这些寄存器之前将它们保存到栈中，并在函数返回前恢复它们：<br><br>  .global foo<br>  foo:<br>  PUSH {R4, R5}           &#x2F;&#x2F; 保存 R4 和 R5 到栈上（被调用者保存寄存器）<br><br>  &#x2F;&#x2F; 使用 R4 和 R5 寄存器进行一些计算<br>  MOV R4, #10             &#x2F;&#x2F; 将 10 存入 R4<br>  MOV R5, #20             &#x2F;&#x2F; 将 20 存入 R5<br>  ADD R6, R4, R5          &#x2F;&#x2F; 将 R4 和 R5 相加，结果存入 R6<br><br>  POP {R4, R5}            &#x2F;&#x2F; 恢复 R4 和 R5 寄存器的值（恢复调用者的状态）<br>  BX LR                   &#x2F;&#x2F; 返回</p>
</li>
<li><p><strong>为何使用 R4~R11 做为被调用者保存寄存器</strong><br>  使用 R4<del>R11 寄存器作为被调用者保存寄存器的原因是为了 减少上下文切换的开销。ARM 架构采用 RISC（精简指令集）原则，要求尽可能通过寄存器传递数据，这样可以提高性能。但为了保证函数调用后原寄存器的状态不会被破坏，采用了这种被调用者保存寄存器的机制。此方式可以在函数内部高效地使用这些寄存器，并通过栈保存和恢复寄存器的值，以维持调用者的原始状态。<br><br>  与 R0-R3 寄存器的对比<br>  R0</del>R3 是 传递函数参数的寄存器，而 R4<del>R11 主要用于 函数内部的临时数据存储 和 局部变量的保存。<br><br>  R0</del>R3 的值在函数返回后由 调用者 负责恢复，而 R4~R11 则由 被调用者 保证状态恢复。</p>
</li>
</ul>
<h2 id="R12IP（Intra-Procedure-call-scratch-register），临时寄存器"><a href="#R12IP（Intra-Procedure-call-scratch-register），临时寄存器" class="headerlink" title="R12	IP（Intra-Procedure-call scratch register），临时寄存器"></a>R12	IP（Intra-Procedure-call scratch register），临时寄存器</h2><ul>
<li><p><strong>临时存储</strong>：</p>
<pre><code>  R12 可以用作临时寄存器，在函数内部进行临时计算或存储中间结果。这是因为它通常用于不需要保留值的操作。
  它在执行过程中不会保存调用者的状态，因此函数内的临时计算可以使用这个寄存器。
</code></pre>
</li>
<li><p><strong>在函数调用中的用途</strong>：</p>
<pre><code>  R12 通常用于 函数调用之间的临时数据存储，比如在函数内传递参数或保存中间结果。
</code></pre>
</li>
<li><p><strong>函数返回的寄存器</strong>：</p>
<pre><code>  虽然 R0 到 R3 用于传递函数参数和返回值，但 R12 也可能在某些函数返回时充当临时传递值或在特定场景下与函数调用相关的临时信息。
</code></pre>
</li>
<li><p><strong>特殊用途</strong>：</p>
<pre><code>  在一些特定的编译器或实现中，R12 也可被当作 工作寄存器 使用，用于特定的计算过程或返回某些函数的中间结果。
</code></pre>
</li>
<li><p><strong>调用约定中的角色</strong>：</p>
<pre><code>  在 ARM 的 AAPCS（ARM Architecture Procedure Call Standard）调用约定中：
  R12 是 调用者保存寄存器，意味着如果调用函数修改了它，调用者有责任在函数返回前恢复它的值。
  一些编译器可能会选择将 R12 作为 临时工作寄存器 使用，这取决于特定的实现，但通常它的使用不依赖于函数参数传递。
</code></pre>
</li>
<li><p><strong>R12 寄存器的实际示例</strong>：</p>
<pre><code>  .global _start
  _start:
  MOV R0, #10      // 将常数 10 存储到 R0 寄存器
  MOV R1, #20      // 将常数 20 存储到 R1 寄存器
  MOV R12, #5      // 将常数 5 存储到 R12 寄存器
  ADD R2, R0, R1   // R2 = R0 + R1 (即 R2 = 10 + 20 = 30)
  ADD R3, R12, R2  // R3 = R12 + R2 (即 R3 = 5 + 30 = 35)
  
  // 此时 R3 = 35，R12 = 5（R12 是临时寄存器）
  BX LR            // 返回（如果有函数调用的话）
</code></pre>
</li>
<li><p><strong>总结</strong></p>
<pre><code>  R12 是一个 调用者保存寄存器，即它是临时寄存器，在函数调用前，调用者不需要担心它的值。如果函数改变了 R12 的值，它需要在返回前将其恢复。
  它通常用于临时存储数据或作为函数内的工作寄存器，允许处理临时值和中间计算结果。
  R12 并不直接参与函数参数传递（R0~R3 负责传递函数参数），而是作为额外的寄存器，在需要时提供灵活性
</code></pre>
</li>
</ul>
<h2 id="R13SP（Stack-Pointer），栈指针"><a href="#R13SP（Stack-Pointer），栈指针" class="headerlink" title="R13	SP（Stack Pointer），栈指针"></a>R13	SP（Stack Pointer），栈指针</h2><ul>
<li><p><strong>栈指针的职责</strong>：</p>
<pre><code>  R13 (SP) 始终指向当前函数调用栈的栈顶位置（即内存中的一个地址）。
  用于保存和恢复函数调用过程中的局部变量、返回地址、保存寄存器值等。
</code></pre>
</li>
<li><p><strong>在函数调用中，R13 通常用于</strong>：</p>
<pre><code>  1.将某些寄存器 PUSH 到栈中（保存现场）
  2.恢复现场 POP 之前保存的寄存器
  3.处理函数的局部变量空间
  4.参数过多时传递超出 R0~R3 的参数
</code></pre>
</li>
<li><p><strong>ARM 模式下 R13 的特殊性</strong></p>
<pre><code>  ARM 支持多个 运行模式（比如 User, FIQ, IRQ, Supervisor, etc.），每个模式可能有自己独立的 R13（SP）寄存器副本。这是为了在异常处理中不互相干扰。
  模式    是否有独立的 SP（R13）
  User    是
  FIQ    是
  IRQ    是
  Supervisor    是
  Abort    是
  Undefined    是
  System    否（使用 User 的 SP）
</code></pre>
</li>
<li><p><strong>使用示例</strong></p>
<pre><code>  PUSH &#123;R4-R7, LR&#125;   ; 将 R4-R7 和返回地址（LR）压入栈
  等价于：
  SUB SP, SP, #20    ; 分配空间
  STR R4, [SP, #0]
  STR R5, [SP, #4]
  STR R6, [SP, #8]
  STR R7, [SP, #12]
  STR LR, [SP, #16]
  恢复现场
  POP &#123;R4-R7, PC&#125;    ; 恢复 R4-R7，PC=LR，相当于返回
</code></pre>
</li>
<li><p><strong>栈生长方向</strong></p>
<pre><code>  ARM 架构中，栈是 向下增长的（地址越来越小）：
  PUSH 操作：SP 减小（分配空间）
  POP 操作：SP 增大（释放空间）
</code></pre>
</li>
<li><p><strong>R13 的命名习惯</strong></p>
<pre><code>  在大多数文档和编译器中，R13 更常写成 SP（stack pointer），功能一样。
  在汇编器中你可以写 MOV SP, #0x2000，它等价于 MOV R13, #0x2000。
</code></pre>
</li>
<li><p><strong>总结</strong><br>  项目    内容<br>  名称    R13 &#x2F; SP（栈指针）<br>  用途    指向当前栈顶，用于保存局部变量、返回地址、寄存器备份等<br>  运行模式    多模式下可有各自独立的 SP<br>  特点    随栈操作自动变化，向下增长<br>  重要性    函数调用、异常处理、上下文切换中都不可或缺的核心寄存器</p>
</li>
</ul>
<h2 id="R14LR（Link-Register），链接寄存器，保存返回地址"><a href="#R14LR（Link-Register），链接寄存器，保存返回地址" class="headerlink" title="R14	LR（Link Register），链接寄存器，保存返回地址"></a>R14	LR（Link Register），链接寄存器，保存返回地址</h2><ul>
<li><p><strong>保存函数返回地址</strong></p>
<pre><code>  LR 保存函数调用时的返回地址。当一个函数被调用时，返回地址（即调用指令之后的地址）会被自动保存到 R14 (LR) 中。
  在 ARM 架构中，BL（Branch with Link）指令用于调用函数，它会将返回地址（当前指令地址 + 4）存储到 LR 中。

  例如：
  BL some_function    // 调用 some_function，将返回地址保存到 LR
  当 some_function 执行完毕后，通常会通过 BX LR 或 MOV PC, LR 指令返回到调用位置，恢复原来的执行流。
</code></pre>
</li>
<li><p><strong>在异常处理中使用</strong></p>
<pre><code>  在 ARM 的 异常模式（例如 IRQ、FIQ）中，LR 会保存异常发生时的返回地址。这使得处理完异常后，能够准确地返回到中断发生前的执行位置。

  在异常模式中，LR 的使用通常有一个模式特定的后缀，比如：

  LR_irq：保存中断返回地址

  LR_fiq：保存快速中断返回地址

  LR_svc：保存系统调用返回地址
</code></pre>
</li>
<li><p><strong>函数返回</strong></p>
<pre><code>  在函数返回时，程序会将 LR 的值传递到 PC（程序计数器） 寄存器中，以实现函数的返回。

  例如：
  BX LR  // 将 LR 寄存器的值（返回地址）加载到 PC 寄存器，实现返回
  LR（R14）与栈的关系
  在函数调用过程中，如果函数调用了其他函数或进入了多个嵌套调用，LR 的值（即返回地址）会被压入栈中保存，以便后续恢复。

  示例：保存和恢复 LR 寄存器
  asm
  PUSH &#123;LR&#125;       // 将 LR 寄存器（返回地址）压栈
  ...
  POP &#123;LR&#125;        // 恢复 LR 寄存器的值
  BX LR           // 从 LR 中获取返回地址，跳回调用者
  R14 (LR) 在 ARM 调用约定中的角色
  根据 AAPCS（ARM Architecture Procedure Call Standard） 调用约定，R14 (LR) 的主要作用是保存函数调用的返回地址。在 函数调用时，返回地址会存储在 LR 中，而 PC（程序计数器） 用来执行代码。
</code></pre>
</li>
<li><p><strong>LR 寄存器与异常模式</strong></p>
<pre><code>  在 ARM 的异常处理机制中，当发生 中断 或 异常 时，LR 也被用来保存中断前的 返回地址。不同的异常模式（例如 IRQ、FIQ、SVC 等）有不同的 LR 寄存器副本。

  模式    LR 寄存器    说明
  User    LR = R14    一般情况下，LR 存储返回地址
  IRQ    LR_irq    保存中断的返回地址
  FIQ    LR_fiq    保存快速中断的返回地址
  Supervisor    LR_svc    保存系统调用的返回地址
  Abort    LR_abt    保存存储访问异常的返回地址
  Undefined    LR_und    保存未定义指令异常的返回地址
</code></pre>
</li>
<li><p><strong>LR 寄存器的使用示例</strong>：</p>
<pre><code>  .global _start

  _start:
  BL some_function   // 调用 some_function，LR 保存返回地址
  // 在这里执行的代码

  some_function:
  PUSH &#123;LR&#125;          // 将 LR（返回地址）保存到栈
  // 执行一些操作
  POP &#123;LR&#125;           // 恢复 LR 的值
  BX LR              // 返回到 _start（LR 指向调用位置）
  在这个示例中，LR 保存了 some_function 的返回地址，当执行完 some_function 后，BX LR 指令将返回到 _start，也就是调用 some_function 的地方。
</code></pre>
</li>
</ul>
<h2 id="R15PC（Program-Counter），程序计数器"><a href="#R15PC（Program-Counter），程序计数器" class="headerlink" title="R15	PC（Program Counter），程序计数器"></a>R15	PC（Program Counter），程序计数器</h2><ul>
<li><p><strong>程序计数器（PC）</strong></p>
<pre><code>  PC（R15）用于存储 当前指令的地址。当处理器执行程序时，PC 存储下一个即将执行的指令的内存地址。

  PC 是 ARM 体系结构中的核心寄存器之一，控制着程序的执行流。
</code></pre>
</li>
<li><p><strong>指令流控制</strong></p>
<pre><code>  在 ARM 架构中，PC 是用于 程序跳转 和 分支控制 的关键寄存器。它决定了处理器从哪个地址加载下一条指令。

  指令通过 分支指令（如 B、BL、BX 等）修改 PC 的值，从而控制程序流。

  B：跳转到目标地址

  BL：跳转到目标地址并保存返回地址（通过 LR）

  BX：跳转到寄存器指定的地址（可以实现函数指针）
</code></pre>
</li>
<li><p><strong>PC 与指令的执行</strong><br>  ARM 架构的 指令 是 顺序执行的，也就是说，通常情况下 PC 会自动增加，指向下一条指令的地址。<br><br>  例如：当前 PC &#x3D; 0x1000，执行完指令后，PC 会自动更新为 0x1004（对于 32 位指令，每条指令 4 字节）。<br><br>  如果执行的是 分支指令，PC 会被直接设置为跳转目标地址。</p>
</li>
<li><p><strong>PC (R15) 与 ARM 汇编的关系</strong></p>
<pre><code>  示例 1: 顺序执行
  在普通的顺序执行中，PC 会指向接下来的指令。
  .global _start

  _start:
  MOV R0, #5     // 当前指令的地址存储在 PC 中
  ADD R1, R0, #3  // 下一条指令的地址存储在 PC 中
  // 执行完后，PC 自动更新指向下一条指令的地址


  示例 2: 跳转指令（分支）
  当遇到 分支指令（B、BL、BX）时，PC 会直接修改为目标地址。
  .global _start

  _start:
  MOV R0, #5
  BL function     // 将返回地址存入 LR，PC 跳转到 function
  MOV R1, #10
  // 执行完后，PC 将跳回函数调用点

  function:
  MOV R2, R0      // 计算参数
  BX LR           // 从 LR 中加载返回地址，返回到 _start
  在上面的代码中：

  BL 将返回地址存入 LR，并将 PC 跳转到 function。

  BX LR 会从 LR 中恢复 PC 的值，从而返回到函数调用点。
</code></pre>
</li>
<li><p><strong>PC 与栈的关系</strong></p>
<pre><code>  在函数调用中，PC 用来指示当前执行的位置，而栈（通过 SP 寄存器）通常用来保存上下文信息，包括 LR（返回地址）。这使得 ARM 可以通过 PC 恢复正常的控制流。
</code></pre>
</li>
<li><p><strong>PC (R15) 与其他寄存器的配合</strong></p>
<pre><code>  PC 与 LR 的配合：
  LR（R14）保存函数的返回地址，而 PC 控制程序的执行流程。函数返回时，PC 从 LR 中加载返回地址。

  PC 与 CPSR 的配合：
  CPSR（当前程序状态寄存器）与 PC 一起工作，保存当前的状态、条件标志和模式信息。CPSR 中的状态标志（如 N、Z、C、V）由 PC 的执行结果来影响。
</code></pre>
</li>
</ul>
<h2 id="程序状态寄存器（PSR）-1"><a href="#程序状态寄存器（PSR）-1" class="headerlink" title="程序状态寄存器（PSR）"></a>程序状态寄存器（PSR）</h2><ul>
<li><p><strong>PSR 的组成</strong></p>
<pre><code>  CPSR (Current Program Status Register)
  CPSR 是当前程序状态寄存器，保存了处理器当前的状态。它通常是 CPU 正在执行的程序的状态寄存器，存储了关于当前指令执行的状态信息。

  SPSR (Saved Program Status Register)
  SPSR 是保存程序状态寄存器，用于异常模式下保存当前 CPSR 的内容。当发生中断或异常时，当前的 CPSR 会被保存到 SPSR 中，以便异常处理结束后能够恢复原来的程序状态。
  SPSR 仅在异常模式下存在，不同的异常模式（如 IRQ、FIQ、SVC 等）有独立的 SPSR 寄存器。
</code></pre>
</li>
<li><p><strong>CPSR 的各个字段</strong></p>
<pre><code>  CPSR 由多个字段组成，下面是它的字段描述：

  字段    位位置    描述
  N    位31    Negative Flag，负数标志。表示最近一次运算结果为负数（例如，运算结果的最高位是 1）。
  Z    位30    Zero Flag，零标志。表示最近一次运算结果为零。
  C    位29    Carry Flag，进位标志。表示最近一次运算产生了进位或借位（对于加法、减法等）。
  V    位28    Overflow Flag，溢出标志。表示最近一次运算结果发生了溢出。
  I    位27    IRQ Disable Flag，IRQ 禁用标志。控制是否允许普通中断（IRQ）。
  F    位26    FIQ Disable Flag，FIQ 禁用标志。控制是否允许快速中断（FIQ）。
  T    位5    Thumb State，指示当前处理器是否在 Thumb 模式 下运行（16 位指令集）。
  M[4:0]    位4-0    Mode Bits，处理器当前的 运行模式。例如 User、Supervisor、IRQ、FIQ 等模式。
</code></pre>
</li>
<li><p><strong>CPSR 的详细字段说明</strong></p>
<pre><code>  N、Z、C、V（条件标志）
          这些是 ARM 状态标志，用于表示上一次运算的结果：
          N（Negative）：表示运算结果是否为负。
          Z（Zero）：表示运算结果是否为零。
          C（Carry）：表示运算是否发生了进位或借位，适用于加法、减法等操作。
          V（Overflow）：表示运算结果是否发生了溢出，尤其是在执行加法或减法时。

  I、F（中断标志）
          I：禁止 IRQ（中断请求）中断。如果该标志设置为 1，则 IRQ 中断被禁用。
          F：禁止 FIQ（快速中断请求）中断。如果该标志设置为 1，则 FIQ 中断被禁用。

  T（Thumb 模式）
          T 标志位用于指示处理器当前是否处于 Thumb 模式。如果该标志为 1，则表示处理器处于 Thumb 模式，即执行 16 位指令。否则，处理器处于 ARM 模式，即执行 32 位指令。

  M[4:0]（运行模式）
          M[4:0] 位字段表示 ARM 处理器当前的 运行模式，它决定了处理器的行为模式。不同的模式会影响寄存器的使用、栈的存储、异常的处理等。常见的运行模式有：
          User Mode（用户模式，M = 0x10）
          FIQ Mode（快速中断模式，M = 0x11）
          IRQ Mode（中断模式，M = 0x12）
          Supervisor Mode（监控模式，M = 0x13）
          Abort Mode（存储访问异常模式，M = 0x17）
          Undefined Mode（未定义指令模式，M = 0x1B）
          System Mode（系统模式，M = 0x1F）
</code></pre>
</li>
<li><p><strong>SPSR 的内容</strong><br>  SPSR 是 CPSR 的一个保存副本，只有在进入异常模式时才会使用。进入异常模式时，CPSR 中的状态（如标志位、运行模式等）会被保存到 SPSR 中。异常处理结束后，处理器会恢复 SPSR 中保存的状态，从而使程序流恢复到异常发生前的状态。</p>
</li>
<li><p><strong>PSR 在异常处理中的作用</strong><br>  当处理器进入异常模式（例如，发生中断或系统调用时），CPSR 会被 保存到 SPSR 中，同时处理器会切换到新的模式。例如，在 IRQ 模式下，CPSR 会保存到 SPSR_irq 中。<br><br>  异常处理过程：<br>  处理器进入异常模式（例如，IRQ）。<br>  将当前的 CPSR 保存到 SPSR_irq。<br>  切换到新的异常模式并开始执行中断处理程序。<br>  异常处理完成后，恢复 SPSR_irq 到 CPSR，恢复处理器的原始状态。<br>  恢复程序执行。</p>
</li>
<li><p><strong>PSR (CPSR 和 SPSR) 的使用示例</strong></p>
<pre><code>  设置 CPSR 标志
  MRS R0, CPSR         // 将 CPSR 的值加载到 R0 寄存器中
  ORR R0, R0, #0x80    // 设置 T 位，将处理器切换到 Thumb 模式
  MSR CPSR, R0         // 将修改后的 CPSR 写回寄存器

  进入异常模式
  SRS #0x13, SPSR     // 保存当前 CPSR 到 SPSR 中，切换到 Supervisor 模式
</code></pre>
</li>
</ul>
<h2 id="Banked-寄存器（银行寄存器）-1"><a href="#Banked-寄存器（银行寄存器）-1" class="headerlink" title="Banked 寄存器（银行寄存器）"></a>Banked 寄存器（银行寄存器）</h2><pre><code>    在 ARM 架构中，Banked Registers（银行寄存器）是指在不同的运行模式下存在的 寄存器副本。每个运行模式可以有独立的寄存器集，这些寄存器在 切换模式时 被切换使用，从而能够在不同的模式中保存和恢复不同的状态。这些寄存器被称为 银行寄存器，它们在 ARM 体系结构中的作用是为了提高上下文切换效率，尤其是在处理中断和异常时。
</code></pre>
<ul>
<li><p><strong>Banked Registers 概述</strong></p>
<pre><code>  ARM 处理器支持多种运行模式（例如，用户模式、异常模式等），每个运行模式都有自己独立的寄存器组。特别是在处理 中断 和 异常 时，ARM 处理器会切换到特定的模式，使用不同的寄存器副本来保存当前的状态信息。

  主要的 Banked Registers
  1.R13 (SP) - 栈指针
  2.R14 (LR) - 链接寄存器
  3.SPSR - 保存程序状态寄存器
  4.CPSR - 当前程序状态寄存器

  这些寄存器的副本在 ARM 的不同运行模式下都有。具体来说，寄存器 R13、R14 和 SPSR 会在不同模式下有不同的副本，称为 banked registers。这样，程序在切换模式时能够保存当前的状态，恢复到之前的工作状态。
</code></pre>
</li>
<li><p><strong>运行模式与 Banked Registers</strong></p>
<pre><code>  ARM 处理器有多个运行模式，每个模式都有独立的 R13、R14 和 SPSR 寄存器副本。常见的运行模式包括：

  User Mode（用户模式）
  FIQ Mode（快速中断模式）
  IRQ Mode（中断模式）
  Supervisor Mode（监控模式）
  Abort Mode（存储访问异常模式）
  Undefined Mode（未定义指令模式）
  System Mode（系统模式）
  每个模式使用 不同的寄存器副本，这就是 banked registers 的概念。
</code></pre>
</li>
<li><p><strong>各模式的 Banked Registers</strong></p>
<pre><code>  ARM 架构中，各个模式的 banked registers 如下表所示：

  模式    R13 (SP)    R14 (LR)    SPSR
  User Mode    R13_usr    R14_usr    无
  FIQ Mode    R13_fiq    R14_fiq    SPSR_fiq
  IRQ Mode    R13_irq    R14_irq    SPSR_irq
  Supervisor Mode    R13_svc    R14_svc    SPSR_svc
  Abort Mode    R13_abt    R14_abt    SPSR_abt
  Undefined Mode    R13_und    R14_und    SPSR_und
  System Mode    R13_sys    R14_sys    无
</code></pre>
</li>
<li><p><strong>寄存器副本的作用</strong></p>
<pre><code>  R13 (SP)：每种模式都有一个独立的 栈指针，以保证在不同模式下，栈的操作不会互相干扰。

  R14 (LR)：每种模式都有一个独立的 链接寄存器，用于保存函数调用的返回地址。不同模式下的函数调用有各自的返回地址，这样切换到异常模式后，函数的返回地址不会被覆盖。

  SPSR：每个异常模式都有一个 保存程序状态寄存器（SPSR），用来保存切换到异常模式前的 CPSR 状态。这样可以在异常处理完成后，恢复到异常发生前的状态。
</code></pre>
</li>
<li><p><strong>Banked Registers 的关键点</strong></p>
<pre><code>  上下文切换：当处理器从 用户模式 切换到 异常模式 时，处理器会使用 SPSR 将 CPSR 保存到栈中，并且使用 banked registers 存储当前的 R13、R14。这样，在异常处理完毕后，处理器可以从 SPSR 中恢复原来的状态，并且使用原来的 R13、R14 寄存器。

  高效的异常处理：使用 banked registers 使得 ARM 处理器能够在处理中断或异常时高效地保存和恢复状态，避免了在切换模式时大量的栈操作，提高了性能。

  示例：中断处理与 Banked Registers
  假设一个 ARM 处理器在进入 IRQ 模式 时，会执行如下操作：
          1.保存当前的 CPSR 到 SPSR_irq。
          2.切换到 IRQ 模式。
          3.使用 R13_irq 和 R14_irq 寄存器来存储栈指针和返回地址。
          4.处理完中断后，使用 SPSR_irq 恢复原来的 CPSR 状态。
          5.从 R14_irq 恢复返回地址，跳回到中断发生前的位置。

  IRQ_Handler:
  // 保存 CPSR 到 SPSR_irq
  MRS R0, CPSR            // 将 CPSR 存入 R0
  MSR SPSR_irq, R0        // 保存到 SPSR_irq
  
  // 切换到 IRQ 模式，保存栈指针和返回地址
  MOV R13, R13_irq        // 使用 IRQ 模式的栈指针
  MOV R14, R14_irq        // 使用 IRQ 模式的链接寄存器
  
  // 执行中断处理
  // ...

  // 恢复状态并返回
  MSR CPSR, SPSR_irq      // 恢复原 CPSR
  MOV PC, R14_irq         // 恢复返回地址并跳转
</code></pre>
</li>
</ul>
<h2 id="控制寄存器（Control-Registers）-1"><a href="#控制寄存器（Control-Registers）-1" class="headerlink" title="控制寄存器（Control Registers）"></a>控制寄存器（Control Registers）</h2><ul>
<li><p><strong>控制寄存器概述</strong></p>
<pre><code>  在 ARM 体系结构中，不同版本的 ARM 处理器可能会有不同的控制寄存器，这些寄存器用于控制内存管理、缓存策略、异常处理等关键系统特性。常见的控制寄存器包括：

  CPSR (Current Program Status Register)
  用于保存当前程序的状态，包括条件标志、模式、控制位等。

  SCTLR (System Control Register)
  用于配置和控制处理器的一些基本特性，如缓存、MMU（内存管理单元）的启用与禁用等。

  ACTLR (Auxiliary Control Register)
  辅助控制寄存器，提供对一些附加功能的控制。

  CPACR (Coproc Access Control Register)
  控制对协处理器的访问权限，例如，浮点协处理器（FPU）或其他扩展协处理器。

  TCR (Translation Control Register)
  用于控制 虚拟地址到物理地址的转换，配置 MMU（内存管理单元）的行为。

  VBAR (Vector Base Address Register)
  用于配置异常向量表的基地址，异常向量表是存储中断和异常处理程序地址的地方。

  FPSCR (Floating Point Status and Control Register)
  用于控制浮点单元的状态和控制浮点运算。
</code></pre>
</li>
<li><p><strong>常见控制寄存器详细介绍</strong><br>  1. CPSR (Current Program Status Register)<br>          CPSR 是 ARM 中最为重要的控制寄存器之一，用于保存当前程序的状态。它包括以下几个主要字段：<br>          N、Z、C、V：条件标志，分别表示负数标志、零标志、进位标志和溢出标志。<br>          I：IRQ 禁用标志，设置为 1 时禁用 IRQ。<br>          F：FIQ 禁用标志，设置为 1 时禁用 FIQ。<br>          T：表示当前是否在 Thumb 模式 下。<br>          M：当前运行模式。它是一个 5 位字段，表示处理器的工作模式（如用户模式、IRQ 模式、FIQ 模式等）。<br><br>  2. SCTLR (System Control Register)<br>          SCTLR 用于配置和控制 ARM 处理器的一些系统特性。它控制的功能包括：<br>          MMU（Memory Management Unit） 的启用与禁用。<br>          缓存控制，包括数据缓存和指令缓存的启用与禁用。<br>          对齐检查，用于控制是否启用内存对齐检查。<br>          中断的使能，允许或禁用处理器对 IRQ 和 FIQ 的响应。<br>          常见的 SCTLR 字段包括：<br>          M (MMU enable)：启用或禁用 MMU。<br>          C (Cache enable)：启用或禁用数据缓存。<br>          I (Instruction Cache enable)：启用或禁用指令缓存。<br>          A (Alignment Check enable)：启用或禁用内存对齐检查。<br>          Z (Tightly-coupled memory)：启用紧耦合内存的访问。<br><br>  3. ACTLR (Auxiliary Control Register)<br>          ACTLR 是一个辅助控制寄存器，用于控制一些附加的功能。其功能在不同 ARM 处理器版本中有所不同，主要控制以下几个方面：<br>          浮点单元（FPU）控制。<br>          缓存的行为控制，例如控制 L2 缓存等。<br><br>  4. CPACR (Coproc Access Control Register)<br>          CPACR 用于控制处理器对协处理器的访问权限。例如，ARM 处理器中有一个浮点单元（FPU），而 CPACR 控制着对浮点协处理器的访问权限。控制此寄存器的主要目的是启用或禁用对协处理器（如 FPU、SIMD 协处理器等）的访问。<br><br>  5. TCR (Translation Control Register)<br>          TCR 用于配置 MMU（内存管理单元） 的行为，特别是在虚拟地址转换过程中。它用于配置不同的内存管理功能，包括地址空间大小、页表的访问权限等。<br><br>  6. VBAR (Vector Base Address Register)<br>          VBAR 用于配置 异常向量表 的基地址。异常向量表是 ARM 处理器用来存储中断和异常处理程序的地址的地方。当发生中断或异常时，处理器会跳转到该表的相应地址。</p>
</li>
<li><p><strong>控制寄存器的使用示例</strong><br>  1. 设置 SCTLR 启用 MMU<br>          MRC p15, 0, R0, c1, c0, 0    &#x2F;&#x2F; 读取 SCTLR 到 R0 寄存器<br>          ORR R0, R0, #1               &#x2F;&#x2F; 设置 M 位以启用 MMU<br>          MCR p15, 0, R0, c1, c0, 0    &#x2F;&#x2F; 将更新后的值写回 SCTLR<br>  2. 启用浮点协处理器访问<br>          MRC p15, 0, R0, c1, c0, 2    &#x2F;&#x2F; 读取 CPACR<br>          ORR R0, R0, #(0xF &lt;&lt; 20)     &#x2F;&#x2F; 启用对浮点协处理器的访问<br>          MCR p15, 0, R0, c1, c0, 2    &#x2F;&#x2F; 将更新后的值写回 CPACR</p>
</li>
</ul>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/sergodeeva">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ARM-%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">ARM 处理器运行模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%EF%BC%88User-Mode%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">用户模式（User Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E4%B8%AD%E6%96%AD%E6%A8%A1%E5%BC%8F%EF%BC%88FIQ-Mode%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">快速中断模式（FIQ Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%BC%8F%EF%BC%88IRQ-Mode%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">中断请求模式（IRQ Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Supervisor-Mode%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">管理模式（Supervisor Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%BC%8F%EF%BC%88Abort-Mode%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">存储访问异常模式（Abort Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Undefined-Mode%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">未定义指令模式（Undefined Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F%EF%BC%88System-Mode%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">系统模式（System Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%88Monitor-Mode%EF%BC%89%EF%BC%88%E4%BB%85%E5%9C%A8-ARMv7-%E6%88%96%E6%9B%B4%E9%AB%98%E7%89%88%E6%9C%AC%E4%B8%AD%E5%AD%98%E5%9C%A8%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">监控模式（Monitor Mode）（仅在 ARMv7 或更高版本中存在）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARM-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">ARM 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88General-Purpose-Registers%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">通用寄存器（General Purpose Registers）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88PSR%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">程序状态寄存器（PSR）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Banked-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E9%93%B6%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">Banked 寄存器（银行寄存器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Control-Registers%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">控制寄存器（Control Registers）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%94%A8%E9%80%94%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">寄存器用途分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#R0-R3-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">R0~R3 寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R4-R11-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">R4~R11 寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R12IP%EF%BC%88Intra-Procedure-call-scratch-register%EF%BC%89%EF%BC%8C%E4%B8%B4%E6%97%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">R12	IP（Intra-Procedure-call scratch register），临时寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R13SP%EF%BC%88Stack-Pointer%EF%BC%89%EF%BC%8C%E6%A0%88%E6%8C%87%E9%92%88"><span class="toc-number">3.4.</span> <span class="toc-text">R13	SP（Stack Pointer），栈指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R14LR%EF%BC%88Link-Register%EF%BC%89%EF%BC%8C%E9%93%BE%E6%8E%A5%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E4%BF%9D%E5%AD%98%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.5.</span> <span class="toc-text">R14	LR（Link Register），链接寄存器，保存返回地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R15PC%EF%BC%88Program-Counter%EF%BC%89%EF%BC%8C%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">R15	PC（Program Counter），程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88PSR%EF%BC%89-1"><span class="toc-number">3.7.</span> <span class="toc-text">程序状态寄存器（PSR）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Banked-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E9%93%B6%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89-1"><span class="toc-number">3.8.</span> <span class="toc-text">Banked 寄存器（银行寄存器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Control-Registers%EF%BC%89-1"><span class="toc-number">3.9.</span> <span class="toc-text">控制寄存器（Control Registers）</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&text=ARM Cortex-M寄存器详解"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&title=ARM Cortex-M寄存器详解"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&is_video=false&description=ARM Cortex-M寄存器详解"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=ARM Cortex-M寄存器详解&body=Check out this article: https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&title=ARM Cortex-M寄存器详解"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&title=ARM Cortex-M寄存器详解"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&title=ARM Cortex-M寄存器详解"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&title=ARM Cortex-M寄存器详解"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://nickshade.github.io/2025/06/29/ARM-Cortex-M%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/&name=ARM Cortex-M寄存器详解&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2025 YAOHAN-LI
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/sergodeeva">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" href="/lib/meslo-LG/styles.css">


<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>



    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



